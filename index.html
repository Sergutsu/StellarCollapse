<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Collapse - Cosmic Block Puzzle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #0f1419 0%, #000510 70%, #000000 100%);
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }
        
        /* Animated Stars Background */
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            opacity: 0.3;
            animation: twinkle 3s infinite ease-in-out;
        }
        
        .star.small {
            width: 1px;
            height: 1px;
            opacity: 0.2;
            animation: twinkle 4s infinite ease-in-out;
        }
        
        .star.medium {
            width: 2px;
            height: 2px;
            opacity: 0.3;
            box-shadow: 0 0 4px rgba(135, 206, 235, 0.4);
            animation: twinkle 2.5s infinite ease-in-out;
        }
        
        .star.large {
            width: 3px;
            height: 3px;
            opacity: 0.4;
            box-shadow: 0 0 6px rgba(255, 182, 193, 0.5);
            animation: twinkle 2s infinite ease-in-out;
        }
        
        .star.nebula {
            width: 4px;
            height: 4px;
            opacity: 0.3;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            box-shadow: 0 0 8px rgba(255, 107, 107, 0.3);
            animation: twinkle 1.8s infinite ease-in-out;
        }
        
        .star.asteroid {
            width: 6px;
            height: 6px;
            opacity: 0.4;
            background: linear-gradient(45deg, #ff4400, #ffdd00, #44ff00, #0088ff);
            border-radius: 30%;
            box-shadow: 0 0 12px rgba(255, 200, 100, 0.6);
            animation: asteroidFloat 5s infinite ease-in-out;
        }
        
        .star.supernova {
            width: 8px;
            height: 8px;
            opacity: 0.5;
            background: radial-gradient(circle, #ffff44, #ff4444, #44ff44, #4444ff);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            animation: supernova 3s infinite ease-in-out;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.1; transform: scale(0.8); }
            50% { opacity: 0.6; transform: scale(1.2); }
        }
        
        @keyframes asteroidFloat {
            0%, 100% { transform: rotate(0deg) scale(1); opacity: 0.4; }
            25% { transform: rotate(90deg) scale(1.1); opacity: 0.6; }
            50% { transform: rotate(180deg) scale(0.9); opacity: 0.5; }
            75% { transform: rotate(270deg) scale(1.05); opacity: 0.7; }
        }
        
        @keyframes supernova {
            0%, 100% { transform: scale(0.8); opacity: 0.3; }
            25% { transform: scale(1.3); opacity: 0.8; }
            50% { transform: scale(1.6); opacity: 1; }
            75% { transform: scale(1.1); opacity: 0.6; }
        }
        

        
        /* Multi-layer game container system */
        .game-container {
            position: relative;
            width: 300px;
            height: 600px;
            border: 3px solid #00d4ff;
            border-radius: 8px;
            box-shadow: 
                0 0 30px rgba(0, 212, 255, 0.5),
                0 0 60px rgba(0, 212, 255, 0.3);
            overflow: hidden;
            animation: borderPulse 4s ease-in-out infinite;
        }
        
        @keyframes borderPulse {
            0%, 100% {
                border-color: #00d4ff;
                box-shadow: 
                    0 0 30px rgba(0, 212, 255, 0.5),
                    0 0 60px rgba(0, 212, 255, 0.3);
            }
            50% {
                border-color: #00b8e6;
                box-shadow: 
                    0 0 40px rgba(0, 212, 255, 0.7),
                    0 0 80px rgba(0, 212, 255, 0.4);
            }
        }
        
        /* Layer 1: Static background grid (never changes, maximum performance) */
        .game-grid-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 20%, rgba(0, 212, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 0, 128, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(0, 20, 40, 0.9) 100%);
            z-index: 1;
            will-change: auto; /* Static layer - no animation optimization needed */
        }
        
        .game-grid-background::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(
                    0deg,
                    transparent 0px,
                    rgba(0, 212, 255, 0.03) 1px,
                    transparent 2px
                ),
                repeating-linear-gradient(
                    90deg,
                    transparent 0px,
                    rgba(0, 212, 255, 0.03) 1px,
                    transparent 2px
                );
            pointer-events: none;
            opacity: 0.6;
        }
        
        .game-grid-background::after {
            content: '';
            position: absolute;
            top: -30%;
            left: -30%;
            width: 160%;
            height: 160%;
            background: linear-gradient(
                45deg,
                transparent 0%,
                transparent 48%,
                rgba(0, 212, 255, 0.3) 49%,
                rgba(0, 212, 255, 0.5) 50%,
                rgba(0, 212, 255, 0.3) 51%,
                transparent 52%,
                transparent 100%
            );
            mix-blend-mode: overlay;
            animation: gridScan 12s linear infinite;
            pointer-events: none;
            opacity: 0.4;
        }
        
        @keyframes gridScan {
            0% {
                transform: translate(-30%, -30%);
            }
            100% {
                transform: translate(30%, 30%);
            }
        }
        
        /* Layer 2: Board state (locked pieces) */
        .game-grid-board {
            position: absolute;
            top: 0;
            left: 0;
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(20, 1fr);
            gap: 2px;
            width: 100%;
            height: 100%;
            z-index: 2;
            will-change: contents; /* Only content changes, not transforms */
            pointer-events: auto; /* This layer should receive clicks */
        }
        
        /* Layer 3: Active falling piece */
        .game-grid-active {
            position: absolute;
            top: 0;
            left: 0;
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(20, 1fr);
            gap: 2px;
            width: 100%;
            height: 100%;
            z-index: 3;
            will-change: transform; /* Optimized for movement animations */
            pointer-events: none; /* Don't interfere with board clicks */
        }
        
        /* Layer 4: Effects and animations */
        .game-grid-effects {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 4;
            pointer-events: none;
            will-change: opacity, transform; /* Optimized for effect animations */
        }
        
        /* Layer 5: UI overlay */
        .game-grid-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
        }
        
        /* Restore original game-grid styles for backward compatibility */
        .game-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(20, 1fr);
            gap: 2px;
            width: 300px;
            height: 600px;
            border: 3px solid #00d4ff;
            background: 
                radial-gradient(circle at 20% 20%, rgba(0, 212, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 0, 128, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(0, 20, 40, 0.9) 100%);
            box-shadow: 
                0 0 30px rgba(0, 212, 255, 0.5),
                inset 0 0 20px rgba(0, 212, 255, 0.1),
                0 0 60px rgba(0, 212, 255, 0.3);
            border-radius: 8px;
            position: relative;
        }
        
        .game-grid::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(
                    0deg,
                    transparent 0px,
                    rgba(0, 212, 255, 0.03) 1px,
                    transparent 2px
                ),
                repeating-linear-gradient(
                    90deg,
                    transparent 0px,
                    rgba(0, 212, 255, 0.03) 1px,
                    transparent 2px
                );
            pointer-events: none;
            border-radius: 6px;
            opacity: 0.6;
            z-index: 3;
        }
        

        

        
        .cell {
            background: rgba(0, 212, 255, 0.02);
            border: 1px solid rgba(0, 212, 255, 0.1);
            border-radius: 2px;
            position: relative;
            /* Performance optimizations for layered rendering */
            backface-visibility: hidden;
            transform: translateZ(0); /* Force hardware acceleration */
        }
        
        .cell:hover {
            background: rgba(0, 212, 255, 0.05);
        }
        
        .cell.filled {
            border: 1px solid rgba(0, 0, 0, 0.3);
            box-shadow: 
                inset 2px 2px 4px rgba(255, 255, 255, 0.2),
                inset -2px -2px 4px rgba(0, 0, 0, 0.5),
                0 2px 8px rgba(0, 0, 0, 0.3);
            cursor: pointer; /* Show it's clickable */
        }
        
        .cell.filled:hover {
            transform: scale(1.05);
            box-shadow: 
                inset 2px 2px 4px rgba(255, 255, 255, 0.3),
                inset -2px -2px 4px rgba(0, 0, 0, 0.6),
                0 4px 12px rgba(0, 212, 255, 0.4);
        }
        
        /* Asteroid-like block styles */
        .cell.red { 
            background: 
                radial-gradient(circle at 30% 30%, #ff6b4a, #cc2200),
                radial-gradient(circle at 70% 80%, #aa1100, #660000),
                linear-gradient(135deg, #ff4400, #aa0000);
            box-shadow: 
                inset 3px 3px 6px rgba(255, 150, 100, 0.3),
                inset -3px -3px 6px rgba(80, 0, 0, 0.7),
                0 3px 12px rgba(255, 68, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }
        
        .cell.red::before {
            content: '🔥';
            position: relative;
            z-index: 2;
            filter: drop-shadow(0 0 2px rgba(255, 100, 0, 0.8));
        }
        
        .cell.red::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 25% 25%, rgba(255, 180, 150, 0.4) 20%, transparent 40%),
                radial-gradient(circle at 75% 70%, rgba(120, 20, 0, 0.6) 15%, transparent 35%),
                radial-gradient(circle at 60% 30%, rgba(200, 50, 20, 0.3) 10%, transparent 25%);
            border-radius: 2px;
            z-index: 1;
        }
        
        .cell.blue { 
            background: 
                radial-gradient(circle at 35% 25%, #4a9eff, #0055cc),
                radial-gradient(circle at 65% 75%, #0044aa, #002266),
                linear-gradient(145deg, #3388ff, #0044aa);
            box-shadow: 
                inset 3px 3px 6px rgba(150, 200, 255, 0.3),
                inset -3px -3px 6px rgba(0, 30, 80, 0.7),
                0 3px 12px rgba(68, 136, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }
        
        .cell.blue::before {
            content: '💎';
            position: relative;
            z-index: 2;
            filter: drop-shadow(0 0 2px rgba(0, 150, 255, 0.8));
        }
        
        .cell.blue::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 40%, rgba(150, 220, 255, 0.4) 20%, transparent 40%),
                radial-gradient(circle at 80% 60%, rgba(0, 50, 120, 0.6) 15%, transparent 35%),
                radial-gradient(circle at 45% 20%, rgba(50, 150, 200, 0.3) 10%, transparent 25%);
            border-radius: 2px;
            z-index: 1;
        }
        
        .cell.green { 
            background: 
                radial-gradient(circle at 40% 30%, #4aff6b, #00cc22),
                radial-gradient(circle at 60% 80%, #00aa11, #006600),
                linear-gradient(125deg, #44ff00, #00aa44);
            box-shadow: 
                inset 3px 3px 6px rgba(150, 255, 180, 0.3),
                inset -3px -3px 6px rgba(0, 80, 30, 0.7),
                0 3px 12px rgba(68, 255, 100, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }
        
        .cell.green::before {
            content: '🌟';
            position: relative;
            z-index: 2;
            filter: drop-shadow(0 0 2px rgba(100, 255, 100, 0.8));
        }
        
        .cell.green::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 30% 30%, rgba(180, 255, 200, 0.4) 20%, transparent 40%),
                radial-gradient(circle at 70% 80%, rgba(20, 120, 40, 0.6) 15%, transparent 35%),
                radial-gradient(circle at 50% 60%, rgba(80, 200, 100, 0.3) 10%, transparent 25%);
            border-radius: 2px;
            z-index: 1;
        }
        
        .cell.yellow { 
            background: 
                radial-gradient(circle at 30% 40%, #ffeb4a, #cc9900),
                radial-gradient(circle at 70% 70%, #aa7700, #664400),
                linear-gradient(155deg, #ffdd00, #aa7700);
            box-shadow: 
                inset 3px 3px 6px rgba(255, 240, 150, 0.3),
                inset -3px -3px 6px rgba(80, 60, 0, 0.7),
                0 3px 12px rgba(255, 221, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }
        
        .cell.yellow::before {
            content: '⚡';
            position: relative;
            z-index: 2;
            filter: drop-shadow(0 0 2px rgba(255, 255, 100, 0.8));
        }
        
        .cell.yellow::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 35% 25%, rgba(255, 250, 180, 0.4) 20%, transparent 40%),
                radial-gradient(circle at 75% 75%, rgba(120, 80, 0, 0.6) 15%, transparent 35%),
                radial-gradient(circle at 55% 45%, rgba(200, 160, 50, 0.3) 10%, transparent 25%);
            border-radius: 2px;
            z-index: 1;
        }
        
        .cell.bomb { 
            background: 
                radial-gradient(circle at 30% 30%, #ff4444, #990000),
                radial-gradient(circle at 70% 70%, #660000, #330000),
                linear-gradient(135deg, #cc0000, #440000);
            box-shadow: 
                inset 3px 3px 6px rgba(255, 100, 100, 0.3),
                inset -3px -3px 6px rgba(60, 0, 0, 0.7),
                0 3px 12px rgba(255, 0, 0, 0.6),
                0 0 20px rgba(255, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            animation: bombPulse 1s ease-in-out infinite;
        }
        
        @keyframes bombPulse {
            0%, 100% { 
                box-shadow: 
                    inset 3px 3px 6px rgba(255, 100, 100, 0.3),
                    inset -3px -3px 6px rgba(60, 0, 0, 0.7),
                    0 3px 12px rgba(255, 0, 0, 0.6),
                    0 0 20px rgba(255, 0, 0, 0.4);
            }
            50% { 
                box-shadow: 
                    inset 3px 3px 6px rgba(255, 100, 100, 0.5),
                    inset -3px -3px 6px rgba(60, 0, 0, 0.9),
                    0 3px 12px rgba(255, 0, 0, 0.8),
                    0 0 30px rgba(255, 0, 0, 0.6);
            }
        }
        
        .cell.bomb::before {
            content: '💣';
            position: relative;
            z-index: 2;
            filter: drop-shadow(0 0 2px rgba(255, 0, 0, 0.8));
        }
        
        .cell.bomb::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 35% 25%, rgba(255, 100, 100, 0.4) 20%, transparent 40%),
                radial-gradient(circle at 75% 75%, rgba(120, 0, 0, 0.6) 15%, transparent 35%),
                radial-gradient(circle at 55% 45%, rgba(200, 50, 50, 0.3) 10%, transparent 25%);
            border-radius: 2px;
            z-index: 1;
        }
        
        .cell.snake { 
            background: 
                radial-gradient(circle at 30% 30%, #00ff88, #006644),
                radial-gradient(circle at 70% 70%, #004433, #002211),
                linear-gradient(45deg, #00cc66, #004433);
            box-shadow: 
                inset 3px 3px 6px rgba(100, 255, 150, 0.3),
                inset -3px -3px 6px rgba(0, 60, 30, 0.7),
                0 3px 12px rgba(0, 255, 100, 0.6),
                0 0 20px rgba(0, 255, 100, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            animation: snakePulse 1.5s ease-in-out infinite;
            transform: rotate(45deg);
        }
        
        @keyframes snakePulse {
            0%, 100% { 
                box-shadow: 
                    inset 3px 3px 6px rgba(100, 255, 150, 0.3),
                    inset -3px -3px 6px rgba(0, 60, 30, 0.7),
                    0 3px 12px rgba(0, 255, 100, 0.6),
                    0 0 20px rgba(0, 255, 100, 0.4);
                transform: rotate(45deg) scale(1);
            }
            50% { 
                box-shadow: 
                    inset 3px 3px 6px rgba(100, 255, 150, 0.5),
                    inset -3px -3px 6px rgba(0, 60, 30, 0.9),
                    0 3px 12px rgba(0, 255, 100, 0.8),
                    0 0 30px rgba(0, 255, 100, 0.6);
                transform: rotate(45deg) scale(1.05);
            }
        }
        
        .cell.snake::before {
            content: '🐍';
            position: relative;
            z-index: 2;
            filter: drop-shadow(0 0 2px rgba(0, 255, 100, 0.8));
            transform: rotate(-45deg);
        }
        
        .cell.snake::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 35% 25%, rgba(100, 255, 150, 0.4) 20%, transparent 40%),
                radial-gradient(circle at 75% 75%, rgba(0, 120, 60, 0.6) 15%, transparent 35%),
                radial-gradient(circle at 55% 45%, rgba(50, 200, 100, 0.3) 10%, transparent 25%);
            border-radius: 2px;
            z-index: 1;
        }
        
        .preview {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            width: 120px;
            height: 120px;
            border: 2px solid #00d4ff;
            background: 
                radial-gradient(circle at 20% 20%, rgba(0, 212, 255, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(0, 20, 40, 0.9) 100%);
            box-shadow: 
                0 0 20px rgba(0, 212, 255, 0.4),
                inset 0 0 15px rgba(0, 212, 255, 0.1);
            border-radius: 6px;
            position: relative;
        }
        
        .preview::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(
                    0deg,
                    transparent 0px,
                    rgba(0, 212, 255, 0.03) 1px,
                    transparent 2px
                ),
                repeating-linear-gradient(
                    90deg,
                    transparent 0px,
                    rgba(0, 212, 255, 0.03) 1px,
                    transparent 2px
                );
            pointer-events: none;
            border-radius: 4px;
        }
        
        .preview-cell {
            background: rgba(0, 212, 255, 0.02);
            border: 1px solid rgba(0, 212, 255, 0.08);
            border-radius: 2px;
        }
        
        .preview-small {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            width: 120px;
            height: 120px;
            border: 1px solid #00d4ff;
            background: 
                radial-gradient(circle at 20% 20%, rgba(0, 212, 255, 0.08) 0%, transparent 50%),
                linear-gradient(135deg, rgba(0, 0, 0, 0.6) 0%, rgba(0, 20, 40, 0.7) 100%);
            box-shadow: 
                0 0 10px rgba(0, 212, 255, 0.2),
                inset 0 0 8px rgba(0, 212, 255, 0.05);
            border-radius: 4px;
            position: relative;
        }
        
        .preview-small::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(
                    0deg,
                    transparent 0px,
                    rgba(0, 212, 255, 0.02) 1px,
                    transparent 2px
                ),
                repeating-linear-gradient(
                    90deg,
                    transparent 0px,
                    rgba(0, 212, 255, 0.02) 1px,
                    transparent 2px
                );
            pointer-events: none;
            border-radius: 3px;
        }
        
        .preview-small-cell {
            background: rgba(0, 212, 255, 0.01);
            border: 1px solid rgba(0, 212, 255, 0.05);
            border-radius: 1px;
            font-size: 8px;
        }
        
        /* Color styles for preview cells */
        .preview-cell.red, .preview-small-cell.red {
            background: radial-gradient(circle at 30% 30%, #ff6b4a, #cc2200);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .preview-cell.red::before, .preview-small-cell.red::before {
            content: '🔥';
            font-size: 12px;
        }
        
        .preview-small-cell.red::before {
            font-size: 8px;
        }
        
        .preview-cell.blue, .preview-small-cell.blue {
            background: radial-gradient(circle at 35% 25%, #4a9eff, #0055cc);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .preview-cell.blue::before, .preview-small-cell.blue::before {
            content: '💎';
            font-size: 12px;
        }
        
        .preview-small-cell.blue::before {
            font-size: 8px;
        }
        
        .preview-cell.green, .preview-small-cell.green {
            background: radial-gradient(circle at 40% 30%, #4aff6b, #00cc22);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .preview-cell.green::before, .preview-small-cell.green::before {
            content: '🌟';
            font-size: 12px;
        }
        
        .preview-small-cell.green::before {
            font-size: 8px;
        }
        
        .preview-cell.yellow, .preview-small-cell.yellow {
            background: radial-gradient(circle at 30% 40%, #ffeb4a, #cc9900);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .preview-cell.yellow::before, .preview-small-cell.yellow::before {
            content: '⚡';
            font-size: 12px;
        }
        
        .preview-small-cell.yellow::before {
            font-size: 8px;
        }
        
        .preview-cell.bomb, .preview-small-cell.bomb {
            background: radial-gradient(circle at 30% 30%, #ff4444, #990000);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.9);
            animation: bombPulse 1s ease-in-out infinite;
        }
        
        .preview-cell.bomb::before, .preview-small-cell.bomb::before {
            content: '💣';
            font-size: 12px;
        }
        
        .preview-small-cell.bomb::before {
            font-size: 8px;
        }
        
        .preview-cell.snake, .preview-small-cell.snake {
            background: radial-gradient(circle at 30% 30%, #00ff88, #006644);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.9);
            animation: snakePulse 1.5s ease-in-out infinite;
            transform: rotate(45deg);
        }
        
        .preview-cell.snake::before, .preview-small-cell.snake::before {
            content: '🐍';
            font-size: 12px;
            transform: rotate(-45deg);
        }
        
        .preview-small-cell.snake::before {
            font-size: 8px;
        }
        
        .screen {
            transition: all 0.5s ease;
        }
        
        .btn {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        

        
        .score-animation {
            animation: scorePulse 0.5s ease;
        }
        
        @keyframes scorePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .highlight {
            box-shadow: 
                0 0 25px 8px rgba(255, 255, 255, 0.9),
                0 0 35px 12px rgba(0, 212, 255, 0.7),
                0 0 45px 16px rgba(255, 0, 128, 0.5);
            z-index: 10;
            animation: asteroidExplode 0.6s ease-in-out;
            transform: scale(1.1);
        }
        
        @keyframes asteroidExplode {
            0% { 
                transform: scale(1);
                box-shadow: 
                    0 0 5px 2px rgba(255, 255, 255, 0.3),
                    0 0 10px 4px rgba(0, 212, 255, 0.2);
            }
            50% { 
                transform: scale(1.15) rotate(5deg);
                box-shadow: 
                    0 0 30px 10px rgba(255, 255, 255, 1),
                    0 0 40px 15px rgba(0, 212, 255, 0.8),
                    0 0 50px 20px rgba(255, 0, 128, 0.6);
            }
            100% { 
                transform: scale(1.1) rotate(-2deg);
                box-shadow: 
                    0 0 25px 8px rgba(255, 255, 255, 0.9),
                    0 0 35px 12px rgba(0, 212, 255, 0.7),
                    0 0 45px 16px rgba(255, 0, 128, 0.5);
            }
        }
        
        /* Special effect for filled cells */
        .cell.filled::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            background: 
                radial-gradient(circle at 70% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 60%),
                radial-gradient(circle at 30% 70%, rgba(255, 255, 255, 0.05) 0%, transparent 40%);
            border-radius: 1px;
            pointer-events: none;
        }
        

        
        .instructions {
            background: 
                linear-gradient(135deg, rgba(0, 212, 255, 0.1) 0%, rgba(255, 0, 128, 0.1) 100%),
                rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 212, 255, 0.3);
            box-shadow: 
                0 0 20px rgba(0, 212, 255, 0.2),
                inset 0 0 20px rgba(0, 212, 255, 0.05);
            border-radius: 8px;
        }
        
        /* Holographic effects for UI panels */
        .hologram-panel {
            background: 
                linear-gradient(135deg, rgba(0, 212, 255, 0.05) 0%, rgba(255, 0, 128, 0.05) 100%),
                rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(6px);
            border: 1px solid rgba(0, 212, 255, 0.2);
            box-shadow: 
                0 0 15px rgba(0, 212, 255, 0.1),
                inset 0 0 15px rgba(0, 212, 255, 0.03);
            border-radius: 6px;
            position: relative;
        }
        
        .hologram-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(
                    90deg,
                    transparent 0px,
                    rgba(0, 212, 255, 0.02) 1px,
                    transparent 2px
                );
            pointer-events: none;
            border-radius: 5px;
        }
        
        /* Enhanced score display */
        .score-display {
            color: #00d4ff;
            text-shadow: 
                0 0 10px rgba(0, 212, 255, 0.8),
                0 0 20px rgba(0, 212, 255, 0.5),
                0 0 30px rgba(0, 212, 255, 0.3);
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
        }
        
        /* Glowing text for headers */
        .glow-text {
            text-shadow: 
                0 0 5px currentColor,
                0 0 10px currentColor,
                0 0 15px currentColor,
                0 0 20px currentColor;
        }
    </style>
</head>
<body class="text-white flex items-center justify-center min-h-screen p-4">
    <!-- Animated Stars Background -->
    <div class="stars" id="starsContainer"></div>
    <!-- Start Screen with Integrated Scoreboard -->    <div id="startScreen" class="screen absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 z-50">
        <div class="flex gap-8 max-w-6xl w-full px-8">
            <!-- Left side - Game info and player input -->
            <div class="flex-1 text-center p-8 rounded-2xl bg-gray-900 bg-opacity-90 backdrop-blur-sm border border-gray-700 relative overflow-hidden">
                <!-- Subtle animated background effects -->
                <div class="absolute inset-0 opacity-3 pointer-events-none">
                    <div class="absolute top-1/4 right-0 w-32 h-32 bg-blue-400 rounded-full blur-3xl animate-pulse" style="animation-duration: 8s;"></div>
                    <div class="absolute bottom-1/4 left-0 w-24 h-24 bg-red-400 rounded-full blur-3xl animate-pulse" style="animation-duration: 10s;"></div>
                    <div class="absolute top-1/2 left-1/2 w-20 h-20 bg-yellow-400 rounded-full blur-3xl animate-pulse" style="animation-duration: 12s;"></div>
                </div>
                <!-- Content with higher z-index -->
                <div class="relative z-10">
                <h1 class="text-5xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-yellow-400 to-red-400">
                    <i class="fas fa-star"></i> STELLAR COLLAPSE
                </h1>
                <p class="text-cyan-300 mb-6">Cosmic blocks with explosive chain reactions!</p>
                
                <!-- Player Name Input -->
                <div class="mb-6">
                    <label class="block text-cyan-300 font-bold mb-2" for="playerName">Enter Your Call Sign:</label>
                    <input type="text" id="playerName" class="bg-gray-900 text-cyan-300 px-4 py-2 rounded-lg border border-cyan-500 focus:border-pink-400 focus:outline-none text-center focus:ring-2 focus:ring-pink-400 focus:ring-opacity-50" 
                           placeholder="Pilot" maxlength="15" value="Pilot">
                </div>
                
                <div class="instructions p-4 rounded-lg mb-6">
                    <h2 class="text-xl font-bold mb-3 text-cyan-300">Mission Briefing</h2>
                    <ul class="text-left text-gray-200 space-y-2">
                        <li><i class="fas fa-rocket text-cyan-400 mr-2"></i> Standard stellar physics apply</li>
                        <li><i class="fas fa-rocket text-cyan-400 mr-2"></i> Match 4 stellar fragments (horizontal or vertical) to trigger collapse</li>
                        <li><i class="fas fa-rocket text-cyan-400 mr-2"></i> Complete stellar lines create massive explosions</li>
                        <li><i class="fas fa-rocket text-cyan-400 mr-2"></i> Use SPACE to rotate, ARROWS to navigate</li>
                    </ul>
                </div>
                
                <button id="startBtn" class="btn bg-gradient-to-r from-cyan-500 to-yellow-500 hover:from-cyan-400 hover:to-yellow-400 text-white font-bold py-3 px-8 rounded-full text-xl shadow-lg shadow-cyan-500/25">
                    <i class="fas fa-play mr-2"></i>BEGIN MISSION
                </button>
                </div> <!-- Close content wrapper -->
            </div>
            
            <!-- Right side - Mission Rankings -->
            <div class="flex-1 p-8 rounded-2xl bg-gray-900 bg-opacity-90 backdrop-blur-sm border border-cyan-500/30 relative overflow-hidden">
                <!-- Subtle animated background effects -->
                <div class="absolute inset-0 opacity-3 pointer-events-none">
                    <div class="absolute top-0 left-0 w-28 h-28 bg-green-400 rounded-full blur-3xl animate-pulse" style="animation-duration: 10s;"></div>
                    <div class="absolute bottom-0 right-0 w-32 h-32 bg-blue-400 rounded-full blur-3xl animate-pulse" style="animation-duration: 12s;"></div>
                    <div class="absolute top-1/3 right-1/3 w-16 h-16 bg-cyan-400 rounded-full blur-3xl animate-pulse" style="animation-duration: 14s;"></div>
                </div>
                <!-- Content with higher z-index -->
                <div class="relative z-10">
                <h2 class="text-3xl font-bold mb-6 text-center text-transparent bg-clip-text bg-gradient-to-r from-blue-400 via-green-400 to-red-400">
                    <i class="fas fa-medal"></i> STELLAR RANKINGS
                </h2>
                
                <div class="mb-6">
                    <div class="flex justify-between border-b border-cyan-600 pb-2 mb-4 font-bold text-cyan-300">
                        <span>Rank</span>
                        <span>Pilot</span>
                        <span>Score</span>
                    </div>
                    <div id="startScreenScoreList" class="space-y-3">
                        <!-- Scores will be inserted here -->
                    </div>
                </div>
                
                <div class="text-center text-cyan-400 text-sm">
                    <p>Master stellar collapse chains for maximum points!</p>
                    <p class="mt-2">Top 5 pilots are immortalized in the cosmos</p>
                </div>
                </div> <!-- Close content wrapper -->
            </div>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="screen absolute inset-0 flex flex-col items-center justify-center opacity-0 pointer-events-none">
        <!-- End Game Button -->
        <div class="absolute top-4 right-4 flex gap-2">
            <button id="soundToggleBtn" class="btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-full transition-colors">
                <i id="soundToggleIcon" class="fas fa-volume-up mr-2"></i><span id="soundToggleText">Sound ON</span>
            </button>
            <button id="endGameBtn" class="btn bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-full transition-colors">
                <i class="fas fa-sign-out-alt mr-2"></i>Exit Mission
            </button>
        </div>
        
        <div class="flex flex-col items-center">
            <div class="flex justify-between w-full max-w-2xl mb-4">
                <div class="text-center hologram-panel p-4">
                    <h2 class="text-2xl font-bold glow-text text-yellow-300">SCORE</h2>
                    <div id="score" class="text-4xl font-bold score-display">0</div>
                </div>
                
                <div class="text-center hologram-panel p-4">
                    <h2 class="text-2xl font-bold glow-text text-blue-300">LEVEL</h2>
                    <div id="level" class="text-4xl font-bold score-display">1</div>
                </div>
                
                <div class="text-center hologram-panel p-4">
                    <h2 class="text-2xl font-bold glow-text text-green-300">LINES</h2>
                    <div id="lines" class="text-4xl font-bold score-display">0</div>
                </div>
            </div>
            
            <div class="flex gap-8">
                <div class="hologram-panel p-4">
                    <h3 class="text-center mb-2 font-bold glow-text text-cyan-300">NEXT</h3>
                    <div class="preview" id="nextPiece"></div>
                    
                    <h4 class="text-center mt-4 mb-2 text-sm font-bold text-cyan-400">COMING UP</h4>
                    <div class="space-y-2">
                        <div class="preview-small" id="nextPiece2"></div>
                        <div class="preview-small" id="nextPiece3"></div>
                        <div class="preview-small" id="nextPiece4"></div>
                    </div>
                </div>
                
                <div class="relative">
                    <!-- Multi-layer game container -->
                    <div class="game-container" id="gameContainer">
                        <!-- Layer 1: Static background grid -->
                        <div class="game-grid-background" id="gridBackground"></div>
                        
                        <!-- Layer 2: Locked pieces (board state) -->
                        <div class="game-grid-board" id="gameBoard"></div>
                        
                        <!-- Layer 3: Active/falling piece -->
                        <div class="game-grid-active" id="activePiece"></div>
                        
                        <!-- Layer 4: Effects and animations -->
                        <div class="game-grid-effects" id="gameEffects"></div>
                        
                        <!-- Layer 5: UI overlay -->
                        <div class="game-grid-ui" id="gameUI"></div>
                    </div>
                    

                </div>
                
                <div class="hologram-panel p-4">
                    <h3 class="text-center mb-2 font-bold glow-text text-cyan-300">CONTROLS</h3>
                    <div class="space-y-2 text-sm">
                        <p class="flex items-center"><i class="fas fa-arrow-up text-yellow-300 mr-2 w-4"></i> Rotate</p>
                        <p class="flex items-center"><i class="fas fa-arrow-left text-yellow-300 mr-2 w-4"></i> Move Left</p>
                        <p class="flex items-center"><i class="fas fa-arrow-right text-yellow-300 mr-2 w-4"></i> Move Right</p>
                        <p class="flex items-center"><i class="fas fa-arrow-down text-yellow-300 mr-2 w-4"></i> Move Down</p>
                        <p class="flex items-center"><i class="fas fa-space-shuttle text-yellow-300 mr-2 w-4"></i> Drop</p>
                        <p class="flex items-center"><i class="fas fa-mouse-pointer text-yellow-300 mr-2 w-4"></i> Match 4+ Colors</p>
                    </div>
                </div>
            </div>
        </div>
    </div>



    <script>
        // Game constants
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const COLORS = ['red', 'blue', 'green', 'yellow', 'bomb', 'snake'];
        
        // Tetromino shapes
        const SHAPES = [
            // I
            [
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ],
            // J
            [
                [1, 0, 0],
                [1, 1, 1],
                [0, 0, 0]
            ],
            // L
            [
                [0, 0, 1],
                [1, 1, 1],
                [0, 0, 0]
            ],
            // O
            [
                [1, 1],
                [1, 1]
            ],
            // S
            [
                [0, 1, 1],
                [1, 1, 0],
                [0, 0, 0]
            ],
            // T
            [
                [0, 1, 0],
                [1, 1, 1],
                [0, 0, 0]
            ],
            // Z
            [
                [1, 1, 0],
                [0, 1, 1],
                [0, 0, 0]
            ],
            // Cross (Plus)
            [
                [0, 1, 0],
                [1, 1, 1],
                [0, 1, 0]
            ],
            // Big L
            [
                [1, 0, 0, 0],
                [1, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0]
            ],
            // Zigzag
            [
                [1, 0, 1],
                [1, 1, 1],
                [0, 0, 0]
            ],
            // X shape
            [
                [1, 0, 1],
                [0, 1, 0],
                [1, 0, 1]
            ],
            // Corner
            [
                [1, 1, 0],
                [1, 0, 0],
                [1, 0, 0]
            ],
            // Diamond (4x4)
            [
                [0, 0, 1, 0],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [0, 1, 1, 0]
            ],
            // Windmill (4x4)
            [
                [1, 0, 0, 1],
                [0, 1, 1, 0],
                [0, 1, 1, 0],
                [1, 0, 0, 1]
            ],
            // Temple (4x4)
            [
                [0, 1, 1, 0],
                [1, 1, 1, 1],
                [1, 0, 0, 1],
                [1, 0, 0, 1]
            ]
        ];
        
        // Game state
        let score = 0;
        let level = 1;
        let lines = 0;
        let gameOver = false;
        let board = [];
        let currentPiece = null;
        let nextPiece = null;
        let pieceQueue = []; // Queue for upcoming pieces
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let highScores = [];
        
        // Sound system
        let audioContext = null;
        let soundEnabled = true;
        let masterVolume = 0.3;
        const soundLibrary = {
            // Sound effect definitions with frequencies and patterns
            pieceDrop: { type: 'tone', frequency: 220, duration: 0.1, volume: 0.2 },
            pieceMove: { type: 'click', frequency: 800, duration: 0.03, volume: 0.15 },
            pieceRotate: { type: 'tone', frequency: 550, duration: 0.08, volume: 0.2 },
            pieceLock: { type: 'thud', frequency: 150, duration: 0.15, volume: 0.25 },
            lineClear: { type: 'sweep', startFreq: 440, endFreq: 880, duration: 0.3, volume: 0.4 },
            colorMatch: { type: 'chord', frequencies: [330, 415, 523], duration: 0.2, volume: 0.3 },
            bombExplosion: { type: 'explosion', duration: 0.6, volume: 0.5 },
            snakeTrail: { type: 'glide', startFreq: 200, endFreq: 800, duration: 0.3, volume: 0.25 },
            gameOver: { type: 'descent', startFreq: 440, endFreq: 110, duration: 1.2, volume: 0.4 },
            levelUp: { type: 'ascent', startFreq: 262, endFreq: 523, duration: 0.5, volume: 0.35 },
            tetris: { type: 'fanfare', frequencies: [262, 330, 392, 523], duration: 0.8, volume: 0.45 }
        };
        
        // DOM elements
        const startScreen = document.getElementById('startScreen');
        const gameScreen = document.getElementById('gameScreen');
        const gameContainer = document.getElementById('gameContainer');
        const gridBackground = document.getElementById('gridBackground');
        const gameBoard = document.getElementById('gameBoard');
        const activePiece = document.getElementById('activePiece');
        const gameEffects = document.getElementById('gameEffects');
        const gameUI = document.getElementById('gameUI');
        // Legacy support
        const gameGrid = document.getElementById('gameGrid') || gameBoard;
        const nextPieceEl = document.getElementById('nextPiece');
        const nextPieceEl2 = document.getElementById('nextPiece2');
        const nextPieceEl3 = document.getElementById('nextPiece3');
        const nextPieceEl4 = document.getElementById('nextPiece4');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const linesEl = document.getElementById('lines');
        const startScreenScoreList = document.getElementById('startScreenScoreList');
        const playerNameInput = document.getElementById('playerName');
        
        // Create animated stars background
        function createStarsBackground() {
            const starsContainer = document.getElementById('starsContainer');
            const numStars = 200; // Increased for more effects
            
            // Create twinkling stars
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                
                // Random star types with new asteroids and supernovas
                const types = ['small', 'medium', 'large', 'nebula', 'asteroid', 'supernova'];
                const weights = [0.4, 0.25, 0.15, 0.1, 0.08, 0.02]; // Probability weights
                let random = Math.random();
                let type = 'small';
                
                for (let j = 0; j < types.length; j++) {
                    if (random < weights[j]) {
                        type = types[j];
                        break;
                    }
                    random -= weights[j];
                }
                
                star.classList.add(type);
                
                // Random position
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                
                // Random animation delay for natural twinkling
                star.style.animationDelay = Math.random() * 3 + 's';
                
                starsContainer.appendChild(star);
            }
        }
        
        // Audio System Functions
        function initAudioSystem() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('Audio system initialized');
            } catch (error) {
                console.warn('Audio not supported:', error);
                soundEnabled = false;
            }
        }
        
        function playSound(soundName, options = {}) {
            if (!soundEnabled || !audioContext || !soundLibrary[soundName]) return;
            
            try {
                const sound = soundLibrary[soundName];
                const volume = (options.volume || sound.volume || 0.3) * masterVolume;
                
                switch (sound.type) {
                    case 'tone':
                        playTone(sound.frequency, sound.duration, volume);
                        break;
                    case 'click':
                        playClick(sound.frequency, sound.duration, volume);
                        break;
                    case 'thud':
                        playThud(sound.frequency, sound.duration, volume);
                        break;
                    case 'sweep':
                        playSweep(sound.startFreq, sound.endFreq, sound.duration, volume);
                        break;
                    case 'chord':
                        playChord(sound.frequencies, sound.duration, volume);
                        break;
                    case 'explosion':
                        playExplosion(sound.duration, volume);
                        break;
                    case 'glide':
                        playGlide(sound.startFreq, sound.endFreq, sound.duration, volume);
                        break;
                    case 'descent':
                        playDescent(sound.startFreq, sound.endFreq, sound.duration, volume);
                        break;
                    case 'ascent':
                        playAscent(sound.startFreq, sound.endFreq, sound.duration, volume);
                        break;
                    case 'fanfare':
                        playFanfare(sound.frequencies, sound.duration, volume);
                        break;
                }
            } catch (error) {
                console.warn('Sound playback error:', error);
            }
        }
        
        function playTone(frequency, duration, volume = 0.3) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function playClick(frequency, duration, volume = 0.15) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function playThud(frequency, duration, volume = 0.25) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'sawtooth';
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function playSweep(startFreq, endFreq, duration, volume = 0.3) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(startFreq, audioContext.currentTime);
            oscillator.frequency.linearRampToValueAtTime(endFreq, audioContext.currentTime + duration);
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.05);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function playChord(frequencies, duration, volume = 0.3) {
            frequencies.forEach((freq, index) => {
                setTimeout(() => {
                    playTone(freq, duration * 0.8, volume / frequencies.length);
                }, index * 50);
            });
        }
        
        function playExplosion(duration, volume = 0.5) {
            // Create noise burst for explosion
            const bufferSize = audioContext.sampleRate * duration;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                output[i] = (Math.random() * 2 - 1) * Math.pow(1 - (i / bufferSize), 2);
            }
            
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            source.buffer = buffer;
            source.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000, audioContext.currentTime);
            filter.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + duration);
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            source.start(audioContext.currentTime);
        }
        
        function playGlide(startFreq, endFreq, duration, volume = 0.25) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(startFreq, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(endFreq, audioContext.currentTime + duration);
            oscillator.type = 'triangle';
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.1);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function playDescent(startFreq, endFreq, duration, volume = 0.4) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(startFreq, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(endFreq, audioContext.currentTime + duration);
            oscillator.type = 'sawtooth';
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function playAscent(startFreq, endFreq, duration, volume = 0.35) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(startFreq, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(endFreq, audioContext.currentTime + duration);
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.1);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function playFanfare(frequencies, duration, volume = 0.45) {
            frequencies.forEach((freq, index) => {
                const delay = index * 0.1;
                setTimeout(() => {
                    playTone(freq, duration - delay, volume / frequencies.length);
                }, delay * 1000);
            });
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            const icon = document.getElementById('soundToggleIcon');
            const text = document.getElementById('soundToggleText');
            
            if (soundEnabled) {
                icon.className = 'fas fa-volume-up mr-2';
                text.textContent = 'Sound ON';
                // Play a test sound to confirm audio is working
                if (audioContext) {
                    playSound('pieceMove');
                }
            } else {
                icon.className = 'fas fa-volume-mute mr-2';
                text.textContent = 'Sound OFF';
            }
        }
        
        // Initialize the game
        function init() {
            // Initialize audio context
            initAudioSystem();
            
            // Create animated stars background
            createStarsBackground();
            
            // Create game board
            createBoard();
            
            // Create next piece preview
            createNextPiecePreview();
            
            // Load high scores
            loadHighScores();
            
            // Event listeners
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('endGameBtn').addEventListener('click', endGameEarly);
            document.getElementById('soundToggleBtn').addEventListener('click', toggleSound);
            
            // Load and display high scores on start screen
            loadHighScores();
            updateStartScreenScores();
            
            // Auto-focus player name input
            playerNameInput.focus();
            playerNameInput.select();
            
            // Keyboard controls
            document.addEventListener('keydown', event => {
                if (gameOver) return;
                
                switch(event.key) {
                    case 'ArrowLeft':
                        event.preventDefault();
                        movePiece(-1);
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        movePiece(1);
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        movePiece(0, 1);
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        rotatePiece();
                        break;
                    case ' ':
                        event.preventDefault();
                        dropPiece();
                        break;
                }
            });
            
            // Mouse controls for matching
            gameContainer.addEventListener('click', handleGridClick);
        }
        
        // Create the game board with layered system
        function createBoard() {
            // Clear all layers
            gameBoard.innerHTML = '';
            activePiece.innerHTML = '';
            gameEffects.innerHTML = '';
            
            board = [];
            
            // Create board state layer (locked pieces)
            for (let y = 0; y < ROWS; y++) {
                board[y] = [];
                for (let x = 0; x < COLS; x++) {
                    board[y][x] = null;
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    gameBoard.appendChild(cell);
                }
            }
            
            // Create active piece layer (transparent cells for current piece)
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.style.background = 'transparent';
                    cell.style.border = 'none';
                    activePiece.appendChild(cell);
                }
            }
        }
        
        // Create next piece preview
        function createNextPiecePreview() {
            // Main preview (4x4)
            nextPieceEl.innerHTML = '';
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'preview-cell';
                    nextPieceEl.appendChild(cell);
                }
            }
            
            // Small previews (4x4 each)
            [nextPieceEl2, nextPieceEl3, nextPieceEl4].forEach(previewEl => {
                previewEl.innerHTML = '';
                for (let y = 0; y < 4; y++) {
                    for (let x = 0; x < 4; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'preview-small-cell';
                        previewEl.appendChild(cell);
                    }
                }
            });
        }
        
        // Initialize piece queue with upcoming pieces
        function initializePieceQueue() {
            pieceQueue = [];
            // Fill the queue with upcoming pieces
            for (let i = 0; i < 5; i++) { // 5 pieces: nextPiece + 4 preview pieces
                pieceQueue.push(createPiece());
            }
        }
        
        // Get next piece from queue and add new one to end
        function getNextPieceFromQueue() {
            const piece = pieceQueue.shift(); // Remove first piece
            pieceQueue.push(createPiece()); // Add new piece to end to maintain queue size
            return piece;
        }
        
        // Update all piece previews
        function updateAllPreviews() {
            updateNextPiecePreview();
            updateSmallPreviews();
        }
        
        // Update small previews (2nd, 3rd, 4th pieces)
        function updateSmallPreviews() {
            const previewElements = [nextPieceEl2, nextPieceEl3, nextPieceEl4];
            
            previewElements.forEach((previewEl, index) => {
                const cells = previewEl.querySelectorAll('.preview-small-cell');
                cells.forEach(cell => cell.className = 'preview-small-cell');
                
                // pieceQueue[0] is nextPiece, so we want indices 1, 2, 3 for small previews
                const queueIndex = index + 1;
                if (pieceQueue[queueIndex]) {
                    const piece = pieceQueue[queueIndex];
                    const shape = piece.shape;
                    const colorMatrix = piece.colorMatrix;
                    
                    for (let y = 0; y < Math.min(shape.length, 4); y++) {
                        for (let x = 0; x < Math.min(shape[y].length, 4); x++) {
                            if (shape[y][x]) {
                                const cellIndex = y * 4 + x;
                                if (cells[cellIndex] && colorMatrix[y][x]) {
                                    cells[cellIndex].classList.add(colorMatrix[y][x]);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Show start screen
        function showStartScreen() {
            gameScreen.classList.add('opacity-0', 'pointer-events-none');
            startScreen.classList.remove('opacity-0', 'pointer-events-none');
            
            updateStartScreenScores();
        }
        
        // Show game screen
        function showGameScreen() {
            startScreen.classList.add('opacity-0', 'pointer-events-none');
            gameScreen.classList.remove('opacity-0', 'pointer-events-none');
        }
        
        // End game early (from end game button)
        function endGameEarly() {
            console.log('EARLY EXIT TRIGGERED!');
            console.log('Setting gameOver = true');
            gameOver = true;
            
            // Clear current piece to stop any ongoing movement
            if (currentPiece) {
                clearPiece();
                currentPiece = null;
            }
            
            // Save score if it qualifies for high scores (silent)
            saveScore(score);
            
            // Go directly to start screen without any dialogs
            showStartScreen();
        }
        
        // Update start screen scoreboard
        function updateStartScreenScores() {
            startScreenScoreList.innerHTML = '';
            
            if (highScores.length === 0) {
                startScreenScoreList.innerHTML = '<div class="text-gray-400 text-center py-4">No high scores yet!<br>Be the first to play!</div>';
                return;
            }
            
            highScores.forEach((entry, index) => {
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center py-2 px-3 rounded border border-gray-700 bg-gray-800 bg-opacity-50';
                div.innerHTML = `
                    <span class="text-yellow-300 font-bold">#${index + 1}</span>
                    <span class="text-white font-medium">${entry.name}</span>
                    <span class="text-green-300 font-bold">${entry.score.toLocaleString()}</span>
                `;
                startScreenScoreList.appendChild(div);
            });
        }
        
        // Start the game
        function startGame() {
            // Ensure audio context is initialized with user gesture
            if (!audioContext && soundEnabled) {
                initAudioSystem();
            }
            
            // Resume audio context if suspended
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Reset game state
            score = 0;
            level = 1;
            lines = 0;
            gameOver = false;
            
            // Update UI
            scoreEl.textContent = '0';
            levelEl.textContent = '1';
            linesEl.textContent = '0';
            
            // Clear board
            createBoard();
            
            // Initialize piece queue and get first pieces
            initializePieceQueue();
            currentPiece = getNextPieceFromQueue();
            nextPiece = getNextPieceFromQueue();
            updateAllPreviews();
            
            // Draw initial piece
            drawPiece();
            
            // Show game screen
            showGameScreen();
            
            // Start game loop
            lastTime = 0;
            dropCounter = 0;
            dropInterval = 1000; // Reset drop interval
            requestAnimationFrame(gameLoop);
        }
        
        // Game loop
        function gameLoop(time = 0) {
            if (gameOver) return;
            
            requestAnimationFrame(gameLoop);
            
            const deltaTime = time - lastTime;
            lastTime = time;
            
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                movePiece(0, 1);
                dropCounter = 0;
            }
            
            // Ensure current piece is always visible
            if (currentPiece) {
                drawPiece();
            }
        }
        
        // Create a new piece
        function createPiece() {
            const type = Math.floor(Math.random() * SHAPES.length);
            const shape = SHAPES[type];
            
            console.log(`Creating piece type ${type} of ${SHAPES.length} total shapes`);
            
            // Create color matrix for multi-colored pieces
            const colorMatrix = [];
            let colorCount = {};
            
            for (let y = 0; y < shape.length; y++) {
                colorMatrix[y] = [];
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        // Assign random color to each block (exclude bomb from normal generation)
                        const normalColors = ['red', 'blue', 'green', 'yellow'];
                        const color = normalColors[Math.floor(Math.random() * normalColors.length)];
                        colorMatrix[y][x] = color;
                        colorCount[color] = (colorCount[color] || 0) + 1;
                    } else {
                        colorMatrix[y][x] = null;
                    }
                }
            }
            
            console.log(`Piece colors:`, colorCount);
            
            return {
                x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
                y: 0,
                shape,
                colorMatrix,
                type
            };
        }
        
        // Update next piece preview
        function updateNextPiecePreview() {
            const cells = nextPieceEl.querySelectorAll('.preview-cell');
            cells.forEach(cell => cell.className = 'preview-cell');
            
            if (!nextPiece) return;
            
            const shape = nextPiece.shape;
            const colorMatrix = nextPiece.colorMatrix;
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const index = y * 4 + x;
                        if (cells[index] && colorMatrix[y][x]) {
                            cells[index].classList.add(colorMatrix[y][x]);
                        }
                    }
                }
            }
        }
        
        // Clear the current piece from active layer
        function clearPiece() {
            if (!currentPiece) return;
            
            // Clear all cells in the active piece layer
            const activeCells = activePiece.querySelectorAll('.cell');
            activeCells.forEach(cell => {
                cell.className = 'cell';
                cell.style.background = 'transparent';
                cell.style.border = 'none';
            });
        }
        
        // Draw the current piece on active layer
        function drawPiece() {
            if (!currentPiece) return;
            
            // First clear the active layer
            clearPiece();
            
            const shape = currentPiece.shape;
            const colorMatrix = currentPiece.colorMatrix;
            
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const boardX = currentPiece.x + x;
                        const boardY = currentPiece.y + y;
                        
                        if (boardY >= 0 && boardX >= 0 && boardX < COLS && boardY < ROWS) {
                            // Use the active piece layer
                            const cell = activePiece.querySelector(`.cell[data-x="${boardX}"][data-y="${boardY}"]`);
                            if (cell && !board[boardY][boardX]) {
                                cell.className = 'cell';
                                if (colorMatrix[y][x]) {
                                    cell.classList.add(colorMatrix[y][x]);
                                }
                                // Remove transparent styling for visible pieces
                                cell.style.background = '';
                                cell.style.border = '';
                            }
                        }
                    }
                }
            }
        }
        
        // Move the current piece
        function movePiece(dx, dy = 0) {
            if (!currentPiece || gameOver) return;
            
            // Clear current position
            clearPiece();
            
            currentPiece.x += dx;
            currentPiece.y += dy;
            
            // Check for collision
            if (isCollision()) {
                currentPiece.x -= dx;
                currentPiece.y -= dy;
                
                // If moving down and collision, lock the piece
                if (dy > 0) {
                    playSound('pieceLock');
                    drawPiece();
                    lockPiece();
                    return;
                }
                
                // Redraw at original position
                drawPiece();
                return;
            }
            
            // Play movement sound for horizontal movement
            if (dx !== 0) {
                playSound('pieceMove');
            } else if (dy > 0) {
                playSound('pieceDrop');
            }
            
            drawPiece();
        }
        
        // Rotate the current piece
        function rotatePiece() {
            if (!currentPiece || gameOver) return;
            
            // Clear current position
            clearPiece();
            
            // Save original shape and color matrix
            const originalShape = currentPiece.shape;
            const originalColorMatrix = currentPiece.colorMatrix;
            
            let newShape, newColorMatrix;
            
            // For square pieces, use standard rotation
            if (originalShape.length === originalShape[0].length) {
                // Standard square rotation (transpose and reverse rows)
                newShape = originalShape.map((row, i) => 
                    row.map((val, j) => originalShape[originalShape.length - 1 - j][i])
                );
                
                // Rotate the color matrix as well
                newColorMatrix = originalColorMatrix.map((row, i) => 
                    row.map((val, j) => originalColorMatrix[originalColorMatrix.length - 1 - j][i])
                );
            } else {
                // For other non-square pieces, create rotated matrix with proper dimensions
                const rows = originalShape.length;
                const cols = originalShape[0].length;
                
                // Create new matrix with swapped dimensions
                newShape = Array(cols).fill(null).map(() => Array(rows).fill(0));
                newColorMatrix = Array(cols).fill(null).map(() => Array(rows).fill(null));
                
                // Rotate by transposing and reversing
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const newY = x;
                        const newX = rows - 1 - y;
                        newShape[newY][newX] = originalShape[y][x];
                        newColorMatrix[newY][newX] = originalColorMatrix[y][x];
                    }
                }
            }
            
            // Apply new shape and colors
            currentPiece.shape = newShape;
            currentPiece.colorMatrix = newColorMatrix;
            
            // Check if rotation is valid
            const originalX = currentPiece.x;
            const originalY = currentPiece.y;
            
            // Try to adjust position if rotation causes collision
            let valid = false;
            
            // First try without moving
            if (!isCollision()) {
                valid = true;
                playSound('pieceRotate'); // Play rotation sound on successful rotation
            } else {
                // Try small position adjustments
                for (let offset = 1; offset <= 2; offset++) {
                    // Try moving left
                    currentPiece.x = originalX - offset;
                    if (!isCollision()) {
                        valid = true;
                        break;
                    }
                    
                    // Try moving right
                    currentPiece.x = originalX + offset;
                    if (!isCollision()) {
                        valid = true;
                        break;
                    }
                    
                    // Reset X for next iteration
                    currentPiece.x = originalX;
                }
            }
            
            // If no valid position found, revert to original
            if (!valid) {
                currentPiece.x = originalX;
                currentPiece.y = originalY;
                currentPiece.shape = originalShape;
                currentPiece.colorMatrix = originalColorMatrix;
            }
            
            // Redraw the piece
            drawPiece();
        }
        
        // Drop the piece to the bottom
        function dropPiece() {
            if (!currentPiece || gameOver) return;
            
            // Clear current position
            clearPiece();
            
            while (!isCollisionAt(0, 1)) {
                currentPiece.y++;
            }
            
            drawPiece();
            lockPiece();
        }
        
        // Check for collision
        function isCollision(dx = 0, dy = 0) {
            if (!currentPiece) return true;
            
            const shape = currentPiece.shape;
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const boardX = currentPiece.x + x + dx;
                        const boardY = currentPiece.y + y + dy;
                        
                        // Check boundaries
                        if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
                            return true;
                        }
                        
                        // Check for collision with locked pieces
                        if (boardY >= 0 && board[boardY] && board[boardY][boardX]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // Check collision at specific position
        function isCollisionAt(dx, dy) {
            if (!currentPiece) return true;
            
            const shape = currentPiece.shape;
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const boardX = currentPiece.x + x + dx;
                        const boardY = currentPiece.y + y + dy;
                        
                        // Check boundaries
                        if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
                            return true;
                        }
                        
                        // Check for collision with locked pieces
                        if (boardY >= 0 && board[boardY] && board[boardY][boardX]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // Lock the piece in place
        function lockPiece() {
            if (!currentPiece) return;
            
            console.log('=== LOCKING PIECE ===');
            if (isBoardAlmostFull()) {
                console.log('WARNING: Board is almost full!');
            }
            
            const shape = currentPiece.shape;
            const colorMatrix = currentPiece.colorMatrix;
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const boardX = currentPiece.x + x;
                        const boardY = currentPiece.y + y;
                        
                        if (boardY < 0) {
                            // Game over
                            console.log('PIECE COLLISION AT TOP - ENDING GAME');
                            endGame();
                            return;
                        }
                        
                        board[boardY][boardX] = colorMatrix[y][x];
                        const cell = document.querySelector(`.cell[data-x="${boardX}"][data-y="${boardY}"]`);
                        if (cell) {
                            cell.className = 'cell filled';
                            if (colorMatrix[y][x]) {
                                cell.classList.add(colorMatrix[y][x]);
                            }
                        }
                    }
                }
            }
            
            // Simple and reliable board full check after locking piece
            console.log('=== LOCK PIECE: Checking if game should end ===');
            
            // Count total filled cells
            let filledCells = 0;
            const totalCells = COLS * ROWS;
            
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x]) {
                        filledCells++;
                    }
                }
            }
            
            const fillPercentage = (filledCells / totalCells) * 100;
            console.log(`Board filled: ${filledCells}/${totalCells} (${fillPercentage.toFixed(1)}%)`);
            
            // End game if board is completely full OR if top 2 rows are blocked
            const boardCompleteFull = filledCells === totalCells;
            
            let topRowsBlocked = true;
            for (let y = 0; y < 2; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (!board[y][x]) {
                        topRowsBlocked = false;
                        break;
                    }
                }
                if (!topRowsBlocked) break;
            }
            
            if (boardCompleteFull) {
                console.log('BOARD COMPLETELY FULL - ENDING GAME');
                endGame();
                return;
            }
            
            if (topRowsBlocked) {
                console.log('TOP 2 ROWS COMPLETELY BLOCKED - ENDING GAME');
                endGame();
                return;
            }
            
            // Check for completed lines
            console.log('Game continues, checking for completed lines...');
            checkLines();
            
            // Create new piece
            if (gameOver) return; // Don't create new pieces if game is over
            
            console.log('Creating new piece...');
            currentPiece = nextPiece;
            nextPiece = getNextPieceFromQueue();
            updateAllPreviews();
            
            // Simple check: if new piece immediately collides, game over
            if (currentPiece && isCollision()) {
                console.log('NEW PIECE COLLISION - GAME OVER');
                endGame();
                return;
            }
            
            // Draw the new piece
            drawPiece();
        }
        
        // Check for completed lines
        function checkLines() {
            if (gameOver) return; // Don't check lines if game is over
            
            let linesCleared = 0;
            
            for (let y = ROWS - 1; y >= 0; y--) {
                let isLineComplete = true;
                for (let x = 0; x < COLS; x++) {
                    if (!board[y][x]) {
                        isLineComplete = false;
                        break;
                    }
                }
                
                if (isLineComplete) {
                    // Remove the line
                    for (let x = 0; x < COLS; x++) {
                        board[y][x] = null;
                    }
                    
                    // Move all lines above down
                    for (let yy = y; yy > 0; yy--) {
                        for (let x = 0; x < COLS; x++) {
                            board[yy][x] = board[yy-1][x];
                        }
                    }
                    
                    // Clear the top line
                    for (let x = 0; x < COLS; x++) {
                        board[0][x] = null;
                    }
                    
                    linesCleared++;
                    y++; // Recheck the same line index since we moved everything down
                }
            }
            
            if (linesCleared > 0) {
                // Play appropriate sound based on lines cleared
                if (linesCleared === 4) {
                    playSound('tetris'); // Special sound for tetris
                } else {
                    playSound('lineClear');
                }
                
                // Update score
                const points = [0, 40, 100, 300, 1200][linesCleared] * level;
                score += points;
                lines += linesCleared;
                
                // Update level every 10 lines
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    playSound('levelUp'); // Play level up sound
                } else {
                    level = newLevel;
                }
                
                // Update UI
                scoreEl.textContent = score;
                levelEl.textContent = level;
                linesEl.textContent = lines;
                
                // Update drop speed (slower for this variant)
                dropInterval = Math.max(200, 1500 - (level - 1) * 75);
                
                // Redraw board
                redrawBoard();
                
                // Apply gravity to ensure proper falling of remaining pieces
                setTimeout(() => {
                    applyGravity();
                }, 50);
            }
        }
        
        // Debug function to test the exact endgame scenario
        function debugTestEndgame() {
            console.log('=== DEBUG: Testing endgame scenario ===');
            
            // Test scenario 1: Complete board fill
            console.log('Test 1: Filling entire board...');
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    board[y][x] = COLORS[Math.floor(Math.random() * COLORS.length)];
                }
            }
            
            redrawBoard();
            
            if (isBoardFull()) {
                console.log('Board is completely full - should trigger endgame');
                endGame();
                return;
            }
            
            console.log('Test 1 failed, trying Test 2...');
            
            // Test scenario 2: Top area congestion
            // Clear board and create congested top area
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    board[y][x] = null;
                }
            }
            
            // Fill most of the board leaving top area very congested
            for (let y = 6; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    board[y][x] = COLORS[Math.floor(Math.random() * COLORS.length)];
                }
            }
            
            // Fill 95% of top 6 rows
            let cellsToFill = Math.floor((6 * COLS) * 0.95);
            let filledCount = 0;
            
            for (let y = 0; y < 6 && filledCount < cellsToFill; y++) {
                for (let x = 0; x < COLS && filledCount < cellsToFill; x++) {
                    board[y][x] = COLORS[Math.floor(Math.random() * COLORS.length)];
                    filledCount++;
                }
            }
            
            redrawBoard();
            console.log('Test 2: Created congested top area scenario');
            
            // Simulate piece locking to trigger congestion check
            setTimeout(() => {
                console.log('Simulating piece lock with congested board...');
                lockPiece();
            }, 1000);
        }
        
        // Simple debug function to test piece creation
        function debugTestPieces() {
            console.log('=== TESTING PIECE CREATION ===');
            console.log(`Total shapes available: ${SHAPES.length}`);
            console.log(`Available colors: ${COLORS.join(', ')}`);
            
            // Create and display 5 test pieces
            for (let i = 0; i < 5; i++) {
                const testPiece = createPiece();
                console.log(`Test piece ${i + 1}:`, {
                    type: testPiece.type,
                    hasColorMatrix: !!testPiece.colorMatrix,
                    shapeSize: testPiece.shape.length + 'x' + testPiece.shape[0].length
                });
            }
        }
        
        // Simple board clear function
        function debugClearBoard() {
            console.log('Clearing board...');
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    board[y][x] = null;
                }
            }
            redrawBoard();
            console.log('Board cleared!');
        }
        
        // Expose simple debug functions
        window.debugTestPieces = debugTestPieces;
        window.debugClearBoard = debugClearBoard;
        
        // Debug function to show board state in console
        function debugShowBoard() {
            console.log('=== CURRENT BOARD STATE ===');
            let emptyCount = 0;
            let boardVisualization = '';
            
            for (let y = 0; y < ROWS; y++) {
                let row = '';
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x]) {
                        row += '█';
                    } else {
                        row += '·';
                        emptyCount++;
                    }
                }
                boardVisualization += `Row ${y.toString().padStart(2)}: ${row}\n`;
            }
            
            console.log(boardVisualization);
            console.log(`Empty cells: ${emptyCount}/${COLS * ROWS}`);
            console.log(`Board full: ${emptyCount === 0}`);
            console.log(`Game over: ${gameOver}`);
            
            return emptyCount;
        }
        
        // Expose debug function
        window.debugShowBoard = debugShowBoard;
        
        // Expose new debug function
        window.debugTestEndgame = debugTestEndgame;
        
        // Debug function to test board full detection (call from console)
        function debugFillBoard() {
            console.log('=== DEBUG: Filling board for testing ===');
            console.log('Current gameOver state:', gameOver);
            
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (!board[y][x]) {
                        board[y][x] = COLORS[Math.floor(Math.random() * COLORS.length)];
                    }
                }
            }
            
            redrawBoard();
            console.log('Board filled. Checking if full...');
            
            const isFull = isBoardFull();
            console.log('isBoardFull result:', isFull);
            
            if (isFull) {
                console.log('Board is full - calling endGame()');
                endGame();
                console.log('endGame() called. New gameOver state:', gameOver);
            } else {
                console.log('Board is not full - endGame not triggered');
            }
        }
        
        // Expose debug function globally
        window.debugFillBoard = debugFillBoard;
        
        // Check if the board is almost full (useful for debugging)
        function isBoardAlmostFull() {
            let emptyCount = 0;
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (!board[y][x]) {
                        emptyCount++;
                    }
                }
            }
            return emptyCount <= 20; // Consider "almost full" when 20 or fewer empty cells
        }
        
        // Check if the board is completely full
        function isBoardFull() {
            let emptyCount = 0;
            let totalCells = COLS * ROWS;
            
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (!board[y][x]) {
                        emptyCount++;
                    }
                }
            }
            
            const filledCells = totalCells - emptyCount;
            const isFull = emptyCount === 0;
            
            // Log when getting close to full or when full
            if (emptyCount <= 10 || isFull) {
                console.log(`Board status: ${emptyCount}/${totalCells} empty cells (${filledCells} filled). Full: ${isFull}`);
                if (isFull) {
                    console.log('TRIGGERING ENDGAME - BOARD IS COMPLETELY FULL!');
                }
            }
            
            return isFull;
        }
        
        // Apply gravity to make pieces fall down
        function applyGravity() {
            let piecesMovedDown = false;
            
            // Work from bottom to top for each column
            for (let x = 0; x < COLS; x++) {
                // Find empty spots and move pieces down
                for (let y = ROWS - 1; y >= 0; y--) {
                    if (!board[y][x]) {
                        // Found empty spot, look for piece above to fall
                        for (let aboveY = y - 1; aboveY >= 0; aboveY--) {
                            if (board[aboveY][x]) {
                                // Move piece down
                                board[y][x] = board[aboveY][x];
                                board[aboveY][x] = null;
                                piecesMovedDown = true;
                                break;
                            }
                        }
                    }
                }
            }
            
            if (piecesMovedDown) {
                // Redraw board after gravity
                redrawBoard();
                
                // Apply gravity again until no more pieces can fall
                setTimeout(() => applyGravity(), 100);
            } else {
                // When gravity is done, check for completed lines
                setTimeout(() => {
                    checkLines();
                }, 150);
            }
        }
        
        // Find matches in a specific direction
        function findMatches(startX, startY, color, deltaX, deltaY) {
            const matches = [{x: startX, y: startY}];
            
            // Check in positive direction
            let x = startX + deltaX;
            let y = startY + deltaY;
            while (x >= 0 && x < COLS && y >= 0 && y < ROWS && board[y][x] === color) {
                matches.push({x, y});
                x += deltaX;
                y += deltaY;
            }
            
            // Check in negative direction
            x = startX - deltaX;
            y = startY - deltaY;
            while (x >= 0 && x < COLS && y >= 0 && y < ROWS && board[y][x] === color) {
                matches.push({x, y});
                x -= deltaX;
                y -= deltaY;
            }
            
            return matches;
        }
        
        // Handle bomb explosion in 5x5 area
        function explodeBomb(centerX, centerY) {
            console.log(`Bomb exploding at (${centerX}, ${centerY})`);
            
            // Play bomb explosion sound
            playSound('bombExplosion');
            
            const explosionCells = [];
            const explosionRadius = 2; // 5x5 area (center ± 2)
            
            // Find all cells in 5x5 area around bomb
            for (let dy = -explosionRadius; dy <= explosionRadius; dy++) {
                for (let dx = -explosionRadius; dx <= explosionRadius; dx++) {
                    const explodeX = centerX + dx;
                    const explodeY = centerY + dy;
                    
                    // Check if coordinates are within board bounds
                    if (explodeX >= 0 && explodeX < COLS && explodeY >= 0 && explodeY < ROWS) {
                        if (board[explodeY][explodeX]) {
                            explosionCells.push({x: explodeX, y: explodeY, color: board[explodeY][explodeX]});
                        }
                    }
                }
            }
            
            console.log(`Bomb will destroy ${explosionCells.length} cells`);
            
            // Highlight all cells that will be destroyed
            explosionCells.forEach(cell => {
                const domCell = gameBoard.querySelector(`.cell[data-x="${cell.x}"][data-y="${cell.y}"]`);
                if (domCell) {
                    domCell.classList.add('highlight');
                }
            });
            
            // Create bomb explosion effects
            explosionCells.forEach(cell => {
                addBombExplosionEffect(cell.x, cell.y);
            });
            
            // Remove all exploded cells after delay
            setTimeout(() => {
                explosionCells.forEach(cell => {
                    board[cell.y][cell.x] = null;
                    const domCell = gameBoard.querySelector(`.cell[data-x="${cell.x}"][data-y="${cell.y}"]`);
                    if (domCell) {
                        domCell.className = 'cell';
                    }
                });
                
                // Calculate massive bomb bonus score
                const bombBonus = explosionCells.length * 25 * level; // Higher multiplier for bomb
                score += bombBonus;
                scoreEl.textContent = score;
                
                // Add animation to score
                scoreEl.classList.add('score-animation');
                setTimeout(() => scoreEl.classList.remove('score-animation'), 500);
                
                // Apply gravity after explosion
                setTimeout(() => {
                    applyGravity();
                }, 100);
                
            }, 500); // Longer delay for bomb explosion
        }
        
        // Activate snake trail animation
        function activateSnake(startX, startY) {
            console.log(`Snake activated at (${startX}, ${startY})`);
            
            // Play snake trail sound
            playSound('snakeTrail');
            
            // Remove the snake block from the board
            board[startY][startX] = null;
            const snakeCell = gameBoard.querySelector(`.cell[data-x="${startX}"][data-y="${startY}"]`);
            if (snakeCell) {
                snakeCell.className = 'cell';
            }
            
            // Generate a path through all filled blocks on the board
            const allBlocks = [];
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x] && board[y][x] !== 'snake' && board[y][x] !== 'bomb') {
                        allBlocks.push({x, y});
                    }
                }
            }
            
            if (allBlocks.length === 0) {
                console.log('No blocks to recolor, snake disappears');
                return;
            }
            
            // Shuffle the blocks for random path
            for (let i = allBlocks.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allBlocks[i], allBlocks[j]] = [allBlocks[j], allBlocks[i]];
            }
            
            // Create snake trail of 5 blocks
            const snakeTrail = [];
            const snakeLength = 5;
            
            // Start snake at random edge of the board
            const edges = [
                {x: -1, y: Math.floor(Math.random() * ROWS)}, // Left edge
                {x: COLS, y: Math.floor(Math.random() * ROWS)}, // Right edge
                {x: Math.floor(Math.random() * COLS), y: -1}, // Top edge
                {x: Math.floor(Math.random() * COLS), y: ROWS} // Bottom edge
            ];
            
            const startEdge = edges[Math.floor(Math.random() * edges.length)];
            
            // Initialize snake trail starting from edge
            for (let i = 0; i < snakeLength; i++) {
                snakeTrail.push({x: startEdge.x, y: startEdge.y, visible: false});
            }
            
            let currentBlockIndex = 0;
            const totalAnimationTime = 5000; // 5 seconds
            const stepInterval = Math.max(50, totalAnimationTime / (allBlocks.length + snakeLength * 2));
            
            console.log(`Snake will visit ${allBlocks.length} blocks over ${totalAnimationTime}ms with ${stepInterval}ms per step`);
            
            // Function to update snake position and recolor blocks
            function moveSnake() {
                // Clear previous snake trail visuals
                document.querySelectorAll('.snake-trail').forEach(element => {
                    element.remove();
                });
                
                // Move snake forward
                if (currentBlockIndex < allBlocks.length) {
                    const targetBlock = allBlocks[currentBlockIndex];
                    
                    // Move each segment of the snake
                    for (let i = snakeLength - 1; i > 0; i--) {
                        snakeTrail[i] = {...snakeTrail[i - 1]};
                    }
                    
                    // Head moves to current target
                    snakeTrail[0] = {x: targetBlock.x, y: targetBlock.y, visible: true};
                    
                    // Recolor the block randomly
                    const normalColors = ['red', 'blue', 'green', 'yellow'];
                    const newColor = normalColors[Math.floor(Math.random() * normalColors.length)];
                    board[targetBlock.y][targetBlock.x] = newColor;
                    
                    // Update DOM
                    const cell = gameBoard.querySelector(`.cell[data-x="${targetBlock.x}"][data-y="${targetBlock.y}"]`);
                    if (cell) {
                        cell.className = `cell ${newColor} filled`;
                    }
                    
                    currentBlockIndex++;
                } else {
                    // Snake is exiting - move towards exit edge
                    const exitEdges = [
                        {x: -2, y: snakeTrail[0].y}, // Exit left
                        {x: COLS + 1, y: snakeTrail[0].y}, // Exit right
                        {x: snakeTrail[0].x, y: -2}, // Exit top
                        {x: snakeTrail[0].x, y: ROWS + 1} // Exit bottom
                    ];
                    
                    const exitEdge = exitEdges[Math.floor(Math.random() * exitEdges.length)];
                    
                    // Move snake towards exit
                    for (let i = snakeLength - 1; i > 0; i--) {
                        snakeTrail[i] = {...snakeTrail[i - 1]};
                    }
                    snakeTrail[0] = {x: exitEdge.x, y: exitEdge.y, visible: false};
                }
                
                // Draw snake trail
                snakeTrail.forEach((segment, index) => {
                    if (segment.visible && segment.x >= 0 && segment.x < COLS && segment.y >= 0 && segment.y < ROWS) {
                        const trailEffect = document.createElement('div');
                        trailEffect.className = 'snake-trail';
                        trailEffect.style.position = 'absolute';
                        trailEffect.style.left = `${(segment.x * 100) / COLS}%`;
                        trailEffect.style.top = `${(segment.y * 100) / ROWS}%`;
                        trailEffect.style.width = `${100 / COLS}%`;
                        trailEffect.style.height = `${100 / ROWS}%`;
                        trailEffect.style.background = index === 0 ? 
                            'radial-gradient(circle, rgba(0, 255, 136, 0.9) 0%, rgba(0, 102, 68, 0.7) 50%, transparent 70%)' :
                            `radial-gradient(circle, rgba(0, 255, 136, ${0.6 - index * 0.1}) 0%, transparent 70%)`;
                        trailEffect.style.borderRadius = '50%';
                        trailEffect.style.transform = 'rotate(45deg)';
                        trailEffect.style.pointerEvents = 'none';
                        trailEffect.style.zIndex = '15';
                        trailEffect.style.animation = `snakeGlow 0.3s ease-in-out`;
                        
                        gameEffects.appendChild(trailEffect);
                    }
                });
                
                // Continue animation or end
                if (currentBlockIndex < allBlocks.length + snakeLength) {
                    setTimeout(moveSnake, stepInterval);
                } else {
                    // Snake animation complete
                    console.log('Snake trail animation complete');
                    // Clean up any remaining visual effects
                    setTimeout(() => {
                        document.querySelectorAll('.snake-trail').forEach(element => {
                            element.remove();
                        });
                        
                        // Apply gravity after snake finishes
                        applyGravity();
                    }, 500);
                }
            }
            
            // Start snake animation
            moveSnake();
        }
        
        // Handle grid click for matching
        function handleGridClick(event) {
            if (gameOver) return;
            
            // Get the clicked element and traverse up to find a cell
            let cell = event.target;
            
            // If clicked on pseudo-element (::before), get the parent cell
            while (cell && !cell.classList.contains('cell')) {
                cell = cell.parentElement;
                if (!cell || cell === gameContainer) {
                    return; // No valid cell found
                }
            }
            
            // Must be a filled cell from the board layer
            if (!cell || !cell.classList.contains('filled')) return;
            
            // Get coordinates
            const x = parseInt(cell.dataset.x);
            const y = parseInt(cell.dataset.y);
            
            // Validate coordinates
            if (isNaN(x) || isNaN(y) || x < 0 || x >= COLS || y < 0 || y >= ROWS) return;
            
            // Must have a color in the board data
            if (!board[y][x]) return;
            
            // Find matching colors from board data (more reliable than DOM classes)
            const color = board[y][x];
            if (!COLORS.includes(color)) return;
            
            console.log(`Clicked cell at (${x}, ${y}) with color: ${color}`);
            
            // Special handling for bomb clicks
            if (color === 'bomb') {
                explodeBomb(x, y);
                return;
            }
            
            // Special handling for snake clicks
            if (color === 'snake') {
                activateSnake(x, y);
                return;
            }
            
            // Check horizontal matches
            const horizontalMatches = findMatches(x, y, color, 1, 0);
            
            // Check vertical matches
            const verticalMatches = findMatches(x, y, color, 0, 1);
            
            let matchesToRemove = [];
            
            // Use horizontal matches if 4 or more
            if (horizontalMatches.length >= 4) {
                matchesToRemove = horizontalMatches;
            }
            // Use vertical matches if 4 or more (and better than horizontal)
            else if (verticalMatches.length >= 4) {
                matchesToRemove = verticalMatches;
            }
            
            console.log(`Found ${matchesToRemove.length} matches to remove`);
            
            // If we have matches to remove
            if (matchesToRemove.length >= 4) {
                // Play color match sound
                playSound('colorMatch');
                
                // Check for special piece creation
                let bombCreated = false;
                let snakeCreated = false;
                
                if (matchesToRemove.length >= 5) {
                    // 5+ match creates bomb at center
                    const centerIndex = Math.floor(matchesToRemove.length / 2);
                    const centerPos = matchesToRemove[centerIndex];
                    bombCreated = true;
                    
                    console.log(`Creating bomb at center position (${centerPos.x}, ${centerPos.y})`);
                } else if (matchesToRemove.length === 4) {
                    // 4-match creates snake at a random position within the match
                    const randomIndex = Math.floor(Math.random() * matchesToRemove.length);
                    const snakePos = matchesToRemove[randomIndex];
                    snakeCreated = true;
                    
                    console.log(`Creating snake at position (${snakePos.x}, ${snakePos.y})`);
                }
                
                // Highlight matched cells
                matchesToRemove.forEach(match => {
                    const cell = gameBoard.querySelector(`.cell[data-x="${match.x}"][data-y="${match.y}"]`);
                    if (cell) {
                        cell.classList.add('highlight');
                    }
                });
                
                // Add explosion effects to each matched cell
                matchesToRemove.forEach(match => {
                    addExplosionEffect(match.x, match.y, color);
                });
                
                // Remove matches after a delay
                setTimeout(() => {
                    if (bombCreated && matchesToRemove.length >= 5) {
                        // Place bomb at center position
                        const centerIndex = Math.floor(matchesToRemove.length / 2);
                        const centerPos = matchesToRemove[centerIndex];
                        
                        // Remove all matches first
                        matchesToRemove.forEach(match => {
                            board[match.y][match.x] = null;
                            const cell = gameBoard.querySelector(`.cell[data-x="${match.x}"][data-y="${match.y}"]`);
                            if (cell) {
                                cell.className = 'cell';
                            }
                        });
                        
                        // Place bomb at center
                        board[centerPos.y][centerPos.x] = 'bomb';
                        const bombCell = gameBoard.querySelector(`.cell[data-x="${centerPos.x}"][data-y="${centerPos.y}"]`);
                        if (bombCell) {
                            bombCell.className = 'cell bomb filled';
                        }
                    } else if (snakeCreated && matchesToRemove.length === 4) {
                        // Place snake at random position within the match
                        const randomIndex = Math.floor(Math.random() * matchesToRemove.length);
                        const snakePos = matchesToRemove[randomIndex];
                        
                        // Remove all matches first
                        matchesToRemove.forEach(match => {
                            board[match.y][match.x] = null;
                            const cell = gameBoard.querySelector(`.cell[data-x="${match.x}"][data-y="${match.y}"]`);
                            if (cell) {
                                cell.className = 'cell';
                            }
                        });
                        
                        // Place snake at chosen position
                        board[snakePos.y][snakePos.x] = 'snake';
                        const snakeCell = gameBoard.querySelector(`.cell[data-x="${snakePos.x}"][data-y="${snakePos.y}"]`);
                        if (snakeCell) {
                            snakeCell.className = 'cell snake filled';
                        }
                    } else {
                        // Normal match removal
                        matchesToRemove.forEach(match => {
                            board[match.y][match.x] = null;
                            const cell = gameBoard.querySelector(`.cell[data-x="${match.x}"][data-y="${match.y}"]`);
                            if (cell) {
                                cell.className = 'cell';
                            }
                        });
                    }
                    
                    // Add score
                    const points = matchesToRemove.length * 10 * level;
                    score += points;
                    scoreEl.textContent = score;
                    
                    // Add animation to score
                    scoreEl.classList.add('score-animation');
                    setTimeout(() => scoreEl.classList.remove('score-animation'), 500);
                    
                    // Apply gravity to make remaining pieces fall
                    setTimeout(() => {
                        applyGravity();
                    }, 100);
                    
                }, 300);
            }
        }
        
        // Add explosion effect to effects layer
        function addExplosionEffect(x, y, color) {
            const effect = document.createElement('div');
            effect.className = 'explosion-effect';
            effect.style.position = 'absolute';
            effect.style.left = `${(x * 100) / COLS}%`;
            effect.style.top = `${(y * 100) / ROWS}%`;
            effect.style.width = `${100 / COLS}%`;
            effect.style.height = `${100 / ROWS}%`;
            effect.style.background = `radial-gradient(circle, ${getColorGradient(color)} 0%, transparent 70%)`;
            effect.style.animation = 'explode 0.6s ease-out forwards';
            effect.style.pointerEvents = 'none';
            effect.style.zIndex = '1';
            
            gameEffects.appendChild(effect);
            
            // Remove effect after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
            }, 600);
        }
        
        // Add bomb explosion effect to effects layer (larger and more dramatic)
        function addBombExplosionEffect(x, y) {
            const effect = document.createElement('div');
            effect.className = 'bomb-explosion-effect';
            effect.style.position = 'absolute';
            effect.style.left = `${(x * 100) / COLS}%`;
            effect.style.top = `${(y * 100) / ROWS}%`;
            effect.style.width = `${100 / COLS}%`;
            effect.style.height = `${100 / ROWS}%`;
            effect.style.background = `radial-gradient(circle, rgba(255, 100, 0, 1) 0%, rgba(255, 200, 0, 0.8) 30%, transparent 70%)`;
            effect.style.animation = 'bombExplode 0.8s ease-out forwards';
            effect.style.pointerEvents = 'none';
            effect.style.zIndex = '10';
            
            gameEffects.appendChild(effect);
            
            // Remove effect after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
            }, 800);
        }
        
        // Get color gradient for effects
        function getColorGradient(color) {
            const gradients = {
                'red': 'rgba(255, 100, 0, 0.8), rgba(255, 200, 100, 0.4)',
                'blue': 'rgba(0, 150, 255, 0.8), rgba(100, 200, 255, 0.4)',
                'green': 'rgba(100, 255, 100, 0.8), rgba(200, 255, 200, 0.4)',
                'yellow': 'rgba(255, 255, 100, 0.8), rgba(255, 255, 200, 0.4)'
            };
            return gradients[color] || 'rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.4)';
        }
        
        // Add CSS animation for explosions
        function addExplosionCSS() {
            const style = document.createElement('style');
            style.textContent = `
                @keyframes explode {
                    0% {
                        transform: scale(0.5) rotate(0deg);
                        opacity: 1;
                    }
                    50% {
                        transform: scale(1.5) rotate(180deg);
                        opacity: 0.8;
                    }
                    100% {
                        transform: scale(2) rotate(360deg);
                        opacity: 0;
                    }
                }
                
                @keyframes bombExplode {
                    0% {
                        transform: scale(0.3) rotate(0deg);
                        opacity: 1;
                    }
                    25% {
                        transform: scale(2) rotate(90deg);
                        opacity: 1;
                    }
                    50% {
                        transform: scale(3) rotate(180deg);
                        opacity: 0.9;
                    }
                    75% {
                        transform: scale(4) rotate(270deg);
                        opacity: 0.6;
                    }
                    100% {
                        transform: scale(5) rotate(360deg);
                        opacity: 0;
                    }
                }
                
                @keyframes snakeGlow {
                    0% {
                        transform: rotate(45deg) scale(0.8);
                        opacity: 0.9;
                        box-shadow: 0 0 15px rgba(0, 255, 136, 0.8);
                    }
                    50% {
                        transform: rotate(45deg) scale(1.1);
                        opacity: 1;
                        box-shadow: 0 0 25px rgba(0, 255, 136, 1);
                    }
                    100% {
                        transform: rotate(45deg) scale(1);
                        opacity: 0.9;
                        box-shadow: 0 0 20px rgba(0, 255, 136, 0.9);
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Initialize explosion CSS
        addExplosionCSS();
        
        // Redraw the entire board using layered system
        function redrawBoard() {
            // Redraw board layer (locked pieces only)
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = gameBoard.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
                    if (cell) {
                        cell.className = 'cell';
                        if (board[y][x]) {
                            cell.classList.add(board[y][x], 'filled');
                        }
                    }
                }
            }
            
            // Redraw active piece on its own layer
            if (currentPiece) {
                drawPiece();
            }
        }
        
        // End the game
        function endGame() {
            console.log('ENDGAME TRIGGERED!');
            console.log('Setting gameOver = true');
            gameOver = true;
            
            // Play game over sound
            playSound('gameOver');
            
            // Clear current piece to stop any ongoing movement
            if (currentPiece) {
                clearPiece();
                currentPiece = null;
            }
            
            // Save score
            saveScore(score);
            
            // Return to start screen immediately
            showStartScreen();
        }
        
        // Save score to high scores
        function saveScore(score) {
            const playerName = playerNameInput.value.trim() || 'Pilot';
            console.log(`Saving score: ${score} for player: ${playerName}`);
            
            highScores.push({name: playerName, score: score});
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 5); // Keep only top 5
            localStorage.setItem('tetrisHighScores', JSON.stringify(highScores));
            
            // Update the start screen scores
            updateStartScreenScores();
        }
        
        // Load high scores
        function loadHighScores() {
            const saved = localStorage.getItem('tetrisHighScores');
            if (saved) {
                highScores = JSON.parse(saved);
            }
        }
        
        // Initialize the game when page loads
        window.addEventListener('load', () => {
            init();
        });
    </script>
</body>
</html>